- [ ] 详细说明推理轨迹（CoT）输出的结构与示例，补充生成与使用细节（§3.2）。
- [ ] 完善编辑脚本（DSL）设计与论证：说明如何处理 move；对比/替换为 SOTA（如 GumTree）并报告影响。
- [ ] 扩展消融实验：分别在单语与跨语言设置，独立评估 ES 与 CoT 的贡献；加入“仅移除 CoT”等可比变体。
- [ ] 补充各语言两阶段（Stage 1/2）结果，并阐明 Stage 2 正确性校验方法与标准。
- [ ] 重新评估数据划分：当前测试集仅 10%，尝试并报告 80/20、70/30 等划分对结果与稳定性的影响。
- [ ] 更谨慎地解读 RQ4 结论：讨论基础模型已见过目标语言的影响；与“直接生成”做更公平对比（改进设置与分析）。
- [ ] 量化第 6.1 节计算开销（训练/推理成本、时延、调用次数等），给出可复现实验数字。
- [ ] 在每个 RQ 末增加“关键结论/启示”小结，强化可复用经验。
- [ ] 在表 1–4 增加与各基线的差值（±x%）列，便于横向比较。
- [ ] 在 RQ1 中验证“将任务表述为推理”的动机：用具体样例对比分类/生成基线失败原因（如缺上下文），并量化占比。
- [ ] 与“推理型模型（隐式 CoT）”对比：说明为何不直接使用/微调推理模型获取轨迹，并给出实验比较。
- [ ] 评估 CoT 轨迹有效性：增加 CoT 消融与对比（含与推理模型原生轨迹的比较），回答其对性能的真实贡献。
- [ ] 深化失败案例分析：给出各类失败的数量分布与比例，并配代表性案例。
- [ ] 澄清贡献边界：明确与既有工作关系（MergeBERT/ChatMerge 的 ES、ConGra 的 CoT、STaR 的数据构造），调整措辞避免过强表述。
- [ ] 解决命名歧义：重命名 §3.2 中的“K”，避免与“2K 次调用”的歧义。
- [ ] 与 MergeBERT、ChatMerge 使用相同数据划分；若不同需在相同划分上复现实验；考虑多随机划分验证稳定性。
- [ ] 说明选择 diff3 与 JDIME 作为基线的理由；明确其“冲突解决”度量口径，并解释如何计算精度/准确率。
- [ ] 解释“准确率高于精度”的现象；如使用了其数据子集，应在相同子集上重跑并报告。
- [ ] 扩充数据集描述：按语言列出训练/验证/测试样本数与规模表。
- [ ] 回应“GPT-4 + 简单 CoT 提示即可”的质疑：提供更有力的对比/论证或实证实验。
- [ ] 讨论/展示是否向开发者呈现 CoT 解释：给出定性示例并（若可）提供初步可用性评估。
- [ ] 明确度量定义与一致性：重申 precision 定义并讨论“何为冲突”的一致性设定对评测的影响。
- [ ] 评估并考虑合并/重构 RQ2（与 RQ1 的关系与冗余）。
- [ ] 修正文稿小问题（按行号）：
  - l.204–205, 248 增补/规范引用；
  - l.212 术语“tentative merge result”澄清；
  - l.213 行尾“||||||||”处理；
  - l.302 解释“highly generalised”；
  - l.315–316 统一 A->1, B->2 标注；
  - l.351 单词“Conflict”检查；
  - l.353, 358 删去示例首行非冲突内容；
  - l.505 定义符号“X”；
  - l.567（及 l.576）定义 r_i；
  - l.621 去掉“about”并补充其他语言的 CoT 情况；
  - l.660 调整“human”措辞（可能为工具选择 OURS）；
  - l.944 删除“large”。
- [ ] 回答审稿问题（用于 rebuttal/修订说明）：
  - 是否与 MergeBERT/ChatMerge 使用完全相同的数据集及折分？
  - 为何选择 diff3/JDIME 以及如何解释其精度/准确率＞0？
  - 模型输入是否仅为冲突块，无更宽上下文？如是，给出理由与影响分析；
  - 在 ES 中如何区分多个出现的同一 token X（实例区分方案）。
